{{template "base" .}}

{{define "title"}}XVI wiek - zapiski{{end}}
{{define "meta_description"}}"Zapiski (podstrona serwisu XVI wiek - ciekawe wydarzenia historyczne w Polsce i krajach sąsiednich)"{{end}}
{{define "meta_title"}}"XVI wiek - zapiski"{{end}}
{{define "canonical"}}<link rel="canonical" href="https://xvi-wiek.pl/zapiski" />{{end}}

{{define "main"}}

    <h1 id="tufte-css">Zapiski</h1>

    <div class="preface">Zapiski, notatki, artykuły i ciekawostki dotyczące programowania, historii, archeologii,
    humanistyki cyfrowej...
    </div>
    <p></p>

    <div>
    <p>
    Spis treści:<br><br>
    <strong>2022-09-25</strong> <a href="#2022-09-25">OpenRefine - własny serwis rekoncyliacji/uspójniania</a><br>
    <strong>2022-10-01</strong> <a href="#2022-10-01">spaCy, NER i półautomatyczne tworzenie indeksu postaci</a><br>
    </p>
    </div>

    <article>
        <hr>
        <h2 id="2022-09-25">OpenRefine - własny serwis rekoncyliacji/uspójniania (<strong>25.09.2022</strong>)</h2>

        <section>
            <p>
                <a href="https://openrefine.org/" target="_blank" rel="noopener">OpenRefine</a>
                jest popularnym narzędziem do oczyszczania i przekształcania danych.

                <label for="%s" class="margin-toggle sidenote-number"></label>
                <input type="checkbox" id="%s" class="margin-toggle"/>
                <span class="sidenote">Polecam artykuły na temat OpenRefine:
                <a href="https://www.pilsudski.org/pl/instytut-cyfrowy/pracownia-digitalizacji/blog/869-oczyszczanie-danych-z-uzyciem-openrefine" target="_blank" rel="noopener">
                Oczyszczanie danych z użyciem OpenRefine
                </a>
                oraz
                <a href="http://programminghistorian.org/en/lessons/cleaning-data-with-openrefine" target="_blank" rel="noopener">
                Cleaning Data with OpenRefine
                </a>
                </span>

                Jedną z jego ciekawszych funkcji jest możliwość rekoncyliacji danych
                przy wykorzystaniu zewnętrznych serwisów udostępniających dane do uspójniania. Często zdarzają 
                się w danych historycznych różnorakie sposoby zapisu imion i nazwisk postaci, lub nazw geograficznych.
                Nazwy miejscowości mogą występować w brzmieniu współczesnym, w formie używanej w XVI wieku,
                lub po prostu w formie błędnie zapisanej w źródle. Mechanizm uspójniania w OpenRefine pozwala
                uzgodnić nazwę występującą w naszych danych z nazwą pochodzącą z pewnego źródła. Np. powiązać
                "Zbigniewa Oleśnickiego" z identyfikatorem z bazy VIAF, lub powiązać miejscowość Brzozowa (występująca
                w źródłach także jako Brosoua) z identyfikatorem z Atlasu Historycznego Polski (Brzozowa_sdc_krk).
            </p>
            <p> Problemem może być znalezienie odpowiedniego serwisu rekoncyliacji. O ile popularne źródła
                w rodzaju VIAF czy wikidata.org są dostępne

                <label for="%s" class="margin-toggle sidenote-number"></label>
                <input type="checkbox" id="%s" class="margin-toggle"/>
                <span class="sidenote"><a href="https://github.com/OpenRefine/OpenRefine/wiki/Reconcilable-Data-Sources" target="_blank" rel="noopener">Lista</a>
                dostępnych serwerów rekoncyliacji
                </span>

                , o tyle uspójnianie z bazą miejscowości AHP lub naszą lokalną
                bazą osób może wymagać uruchomienia własnego serwisu. Nie jest to jednak takie trudne, istnieją
                bowiem gotowe narzędzia, które można wykorzystać do tego celu. Jednym z nich jest
                <strong>Reconcile-csv</strong> udostępniony (na otwartej licencji BSD-2) na stronie
                <a href="http://okfnlabs.org/reconcile-csv/" target="_blank" rel="noopener">Open Knowledge Lab</a>.
                Program ten pozwala na dopasowanie szukanej przez nas nazwy do nazw w swojej bazie poprzez
                mechanizm przybliżonego (rozmytego) porównywania (fuzzy matching), nazwy nie muszą
                być identyczne, mogą być podobne, program będzie wówczas proponował listę zbliżonych
                do podanej nazw wraz ze współczynnikiem podobieństwa. Bazą dla Reconcile-csv
                jest plik tekstowy w formacie CSV.  
            </p>

            <p>
            Program jest plikiem *.jar,
            (warto pobrać z <a href="https://github.com/okfn/reconcile-csv" target="_blank" rel="noopener">githuba</a>
            też plik index.html.tpl, który jest szablonem
            wyświetlanym jako główna strona serwisu) do uruchomienia potrzebuje więc zainstalowanej Javy (JRE),
            potrzebny jest oczywiście plik CSV z danymi (plik w którym każdy wiersz jest rekordem
            danych, pola rozdzielone są przecinkami a pierwszy wiersz zawiera nazwy kolumn).
            </p>

            <p>
            Polecenie uruchamiające serwer:<br>
            <code>
                java -Xmx2g -jar reconcile-csv-0.1.2.jar plik.csv search_column id_column
            </code>
            </p>

            <p>
            gdzie <code>plik.csv</code> to nazwa naszego pliku z danymi, <code>search_columm</code>
            to nazwa pola w pliku z danymi, które będzie służyło do rekoncyliacji w OpenRefine,
            <code>id_column</code> to nazwa pola w pliku z danymi, które zawiera jednoznaczny identyfikator danych.
            </p>

            <p>Po uruchomieniu serwis dostępny jest pod adresem <em>http://localhost:8000/reconcile</em>,
            i taki adres należy wprowadzić w OpenRefine (zwraca on zawartość w formacie json, czytelną dla
            programu - odbiorcy danych z serwisu). Adres główny serwisu (<em>http://localhost:8000</em>)
            wyświetli o nim podstawowe informacje w formie czytelnej dla człowieka.
            </p>
            <img src="/static/img_zapiski/reconcile_csv_01.png" width="500" alt="serwis reconcile-csv"/>

            <p>
            Lokalny serwis rekoncyliacji podłącza się do OpenRefine podobnie jak serwisy zewnętrzne,
            po uruchomieniu rekoncyliacji na wybranej kolumnie danych przycisk Add Standard Service wyświetli
            okienko w którym można podać adres serwisu, zaakceptowany serwis pojawi się na liście.
            <label for="%s" class="margin-toggle sidenote-number"></label>
            <input type="checkbox" id="%s" class="margin-toggle"/>
            <span class="sidenote">Standardowa nazwa serwisu będzie różnić się od pokazanej na
            ilustracji i wygląda tak: 'CSV Reconciliation service'. Jest niestety zaszyta w kodzie źródłowym
            Reconcile-csv i jej zmiana wymaga rekompilacji programu (zob. dalszą część artykułu).
            </span>
            </p>
            <img src="/static/img_zapiski/reconcile_csv_04.png" width="500" alt="add standard service"/>

            <p>
            Można wówczas rozpocząć proces uspójniania. Dane które według mechanizmu zostały pewnie dopasowane
            (współczynnik > 0.85) zostaną od razu przypisane do komórek kolumny dla której przeprowadzamy
            rekoncyliację, w innych przypadkach wyświetlona zostanie lista wraz z wartościami dopasowania.
            Dla każdej z pozycji można wyświetlić informacje z pliku csv będącego źródłem danych serwisu, na
            przykładzie poniżej są to dane miejscowości z Atlasu Historycznego Polski.
            <label for="%s" class="margin-toggle sidenote-number"></label>
            <input type="checkbox" id="%s" class="margin-toggle"/>
            <span class="sidenote">Dostępne publicznie na licencji CC BY-ND 4.0:
            <a href="https://data.atlasfontium.pl/documents/202?_ga=2.122616834.865899583.1640103019-2000553280.1624037407" target="_blank" rel="noopener">
            AHP 2.0</a> (IH PAN).
            </span>
            </p>
            <img src="/static/img_zapiski/reconcile_csv_11.png" width="500" alt="reconcile_view"/>

            <p><strong>Jak zmodyfikować program reconcile-csv</strong>:
            zarówno zmiana nazwy serwisu (nazwy wyświetlanej w OpenRefine), jak i dostosowanie programu
            Reconcile-csv do pracy na serwerze, wymaga zmian w jego kodzie źródłowym
            <label for="%s" class="margin-toggle sidenote-number"></label>
            <input type="checkbox" id="%s" class="margin-toggle"/>
            <span class="sidenote">Repozytorium aplikacji w serwisie
            <a href="https://github.com/okfn/reconcile-csv">github</a>.
            </span>
            a w związku z tym pewnych umiejętności 'programistycznych'.
            Sama zmiana nazwy serwisu wymaga jednak tylko modyfikacji 50 wiersza pliku
            /src/reconcile_csv/core.clj: <code> {:name "CSV Reconciliation service"</code>,
            zmiany tekstu <em>"CSV Reconciliation service"</em> na nowy i rekompilacji programu.
            Aplikacja została stworzona w języku clojure. Najłatwiejszym sposobem zarządzania i kompilacji projektu
            w języku clojure jest użycie systemu
            <a href="https://leiningen.org/" target="_blank" rel="noopener">Leiningen</a>, który w systemie
            Ubuntu można zainstalować poleceniem: <code>sudo apt install leiningen</code>.
            Rekompilacja projektu Reconcile-csv i budowa nowego pliku *.jar sprowadza się do
            uruchomienia polecenia: <code>lein uberjar</code> w katalogu z plikiem project.cli,
            skompilowany plik *.jar powinien znajdować się w podkatalogu <code>/target</code>.
            </p>

            <p>
            Modyfikacja kodu i rekompilacja za każdym razem kiedy chcemy zmienić np. nazwę serwisu
            rekoncyliacji wyświetlaną w OpenRefine może być jednak dość niewygodna. Dlatego przygotowałem małą
            modyfikację programu reconcile-cvs która obsługuje cztery dodatkowe parametry uruchamiania z linii komend:
            <code>adres_serwera</code>, <code>port</code>, <code>nazwa_serwisu_rekoncyliacji</code> i <code>nazwa_typu</code>.
            Dodatkowo serwis wyświetla trochę bardziej czytelny podgląd danych z pliku csv, podczas
            uspójniania (widoczne ramki tabeli).
            <img src="/static/img_zapiski/reconcile_csv_table.jpg" width="500" alt="reconcile_view"/>
            </p>

            <p>Przykładowe wywołanie:<br>
            <code>
             java -Xmx2g -jar reconcile-csv-0.1.2.jar plik.csv search_column id_column "http://moj_serwer.org" "80" "Miasta-Osoby Serwis Rekoncyliacji" "miasta_osoby"
            </code>
            <p>
            <p>
            lub (obecnie port inny niż 80 trzeba podać także w adresie serwera):<br>
            <code>
             java -Xmx2g -jar reconcile-csv-0.1.2.jar plik.csv search_column id_column "http://localhost:8000" "8000" "Miasta-Osoby Serwis Rekoncyliacji" "miasta_osoby"
            </code>
            </p>

            <p>Kod źródłowy modyfikacji można pobrać z <a href="https://github.com/pjaskulski/reconcile-csv" target="_blank" rel="noopener">github</a>,
            skompilowany plik jar również: <a href="https://github.com/pjaskulski/reconcile-csv/releases" target="_blank" rel="noopener">releases</a>.
            </p>
        </section>
    </article>

    <article>
        <hr>
        <h2 id="2022-10-01">spaCy, NER i półautomatyczne tworzenie indeksu postaci (<strong>01.10.2022</strong>)</h2>

        <section>

        <p>Postęp rozwoju metod przetwarzania języka naturalnego (NLP) w ciągu ostatnich kilku lat pozwala
        na coraz szersze ich użycie, także w odniesieniu do tekstów w języku polskim. Jedną z technik NLP
        jest rozpoznawanie jednostek nazwanych (NER - named entity recogition), w czystym, pozbawionym struktury
        tekście poddanym analizie NER można oznaczyć np. osoby, miejsca czy daty. Do czego może się to przydać w przypadku
        publikacji historycznych? Jednym z naprostszych przypadków użycia jaki przychodzi do głowy jest stworzenie
        indeksu osób dla publikacji gdzie takiego indeksu brakuje.</p>

        <p>Do testu posłuży artykuł (właściwie książka, sądząc po objętości) Stanisława Bodniaka, "Polska a Bałtyk za ostatniego z Jagiellona"
        wydana w 1946 roku (<em>Pamiętnik Biblioteki Kórnickiej</em> 3, 42-276, 1939-46).
        <label for="%s" class="margin-toggle sidenote-number"></label>
        <input type="checkbox" id="%s" class="margin-toggle"/>
        <span class="sidenote">
        Dzieło to ma zresztą ciekawą historię gdyż pierwszy druk i rękopis zostały utracone
        w wyniku działań wojennych, autor z zachowanych korekt i notatek
        odtworzył i wydał je po wojnie.
        </span>
        Publikacja została zdigitalizowana przez Muzeum Historii Polski i udostępniona w bazie
        bazhum.muzhp.pl w formie pdf.
        </p>
        <p>
        Sytuacja jednak nie jest idealna - pdf nie ma indeksu (nie wiem czy jest w papierowym
        wydaniu), ma warstwę OCR więc jest przeszukiwalny, jednak jakość OCR nie jest perfekcyjna,
        w tekście pojawiają się np. przypadkowe spacje wewnątrz słów. Aby to poprawić można
        proces ocr przeprowadzić powtórnie.
        <label for="%s" class="margin-toggle sidenote-number"></label>
        <input type="checkbox" id="%s" class="margin-toggle"/>
        <span class="sidenote">Ponieważ na codzień pracuję w systemie Linux, narzędzia których używam związane są z
        tym systemem, jednak wiele z nich pracuje także pod Windows/Mac lub istnieją odpowiedniki
        dla tych środowisk.
        </span>
        </p>
        <img src="/static/img_zapiski/tekst_z_warstwy_ocr_pdfa.png" width="500" alt="reconcile_view"/>

        <p>Ciekawym narzędziem do wprowadzania warstwy tekstowej ocr do plików pdf jest
        <a href="https://ocrmypdf.readthedocs.io/en/latest/introduction.html">ocrmypdf</a>, może
        on rówież nadpisać istniejącą warstwę tekstową czy zapisać rozpoznany przez ocr na nowo
        tekst w osobnym pliku tekstowym (warstwa tekstowa zapisana przez ten program w pdf
        również nie była rewelacyjna, ale sam plik z tekstem okazał się niezły i nadawał się
        do dalszej obróbki). Silnikiem OCR używanym przez omawianą apliację jest Tesseract,
        uważany za najlepszy mechanizm OCR open source.
        </p>
        <p>
        Polecenie uruchamiające przetwarzanie pdf-a wygląda tak:<br>
        <code>
        ocrmypdf -l pol --force-ocr --sidecar output.txt Bodniak_input.pdf Bodniak_output.pdf
        </code>
        </p>

        <p>
        gdzie opcja: <code>-l pol</code> odpowiada za obsługę języka polskiego,
        <code>--force-ocr</code> wymusza nadpisanie istniejącej warstwy ocr w pdf,
        zaś opcja <code>--sidecar output.txt</code> powoduje zapisanie tekstu z pdf
        w pliku tekstowym. Nazwy plików pdf na końcu to odpowiednio oryginalny plik
        oraz wyjściowy zmodyfikowany plik pdf.
        </p>

        <p>
        Oryginalny plik pdf pobrany z repozytorium bazhum.muzhp.pl może wymagać wstępnego
        przetworzenia (programo ocrmypdf zgłasza błąd "EncryptedPdfError: Input PDF is encrypted.
        The encryption must be removed to perform OCR"), służy do tego program qpdf uruchamiany
        z linii komend: <code>qpdf --decrypt plik_wejściowy.pdf plik wyjściowy.pdf</code>.
        </p>

        <p>
        Innym narzędziem, które może posłużyć do wydobycia tekstu z pliku pdf jest program
        gImageReader będący graficzną nakładką na silnik OCR Tesseract, oprócz samego procesu
        OCR ma on dodatkowe funkcje pozwalające usunąć znaki końca wiersza ze środka akapitów
        oraz połączyć wyrazy podzielone między wiersze (komercyjne programy OCR mają z pewnością
        dużo większe możliwości w zakresie oczyszczania i poprawiania tekstu po procesie OCR).
        </p>
        <img src="/static/img_zapiski/tekst_po_ocr_gImageReader_Tesseract.png" width="500" alt="tekst_gimage_reader"/>

        <p>Mając plik z tekstem (z zachowanymi numerami stron, które zamieniłem na tagi w postaci
        <code>[PAGE: 45]</code> na początku każdej strony) możemy poddać go próbnej analizie NER.
        Istnieje bardzo wiele narzędzi i modeli, które można wykorzystać do tego celu, dostępna
        jest np. kolekcja narzędzi projektu CLARIN-PL (analiza NER do przetestowania także:
        <a href="https://ws.clarin-pl.eu/ner">on-line</a>). W tym teście skorzystam jednak z
        popularnej biblioteki NLP: <a href="https://spacy.io/">spaCy</a> i skryptów w języku Python.
        </p>

        <p>Najwygodniejszym sposobem testowania różnych rozwiązań w Pythonie jest środowisko
        <a href="https://jupyter.org/">Jupyter Notebook</a>
        Sama instalacja i konfiguracja Pythona, Jupytera i spaCy to temat na osobną zapiskę, ale
        procudury ich instalacji są przystępnie opisane na podanych wyżej stronach.
        </p>

        <p>
        Po uruchomieniu środowiska Jupyter i utworzeniu nowego notatnika należy zaimportować
        bibliotekę spacy oraz dodatkowo mechanizm wizualizacji displacy. Kolejnym krokiem będzie
        załadowanie tekstu do analizy oraz modelu dla języka polskiego. Standardowo spaCy oferuje
        3 modele (zob. <a href="https://spacy.io/models/pl">https://spacy.io/models/pl</a>), mały,
        średni i duży, różniące się wielkością (od 20 do 500 MB) i dokładnością. Do celów tego testu
        wystarczy model średni 'pl_core_news_md' (<em>Polish pipeline optimized for CPU. Components:
        tok2vec, morphologizer, parser, lemmatizer (trainable_lemmatizer), tagger, senter, ner.</em>).
        </p>

        <p>
        <code>
        import spacy<br>
        from spacy import displacy<br><br>

        nlp = spacy.load('pl_core_news_md')<br>
        with open('../data/bodniak_baltyk_small.txt', 'r', encoding='utf-8') as f:<br>
            text = f.read()<br><br>

        doc = nlp(text)<br>
        displacy.render(doc, style='ent')<br>
        </code>
        </p>

        <p>
        Kod podany powyżej przeprowadza analizę NER wczytanego tekstu (jest to fragment
        artykułu S. Bodniaka, str. 43) oraz wyświetla wynik w bardzo przystępnej formie,
        gdzie znalezione jednostki nazwane (osoby, daty i miejsca) oznaczone są kolorami
        i etykietą. Jak widać mechanizm radzi sobie całkiem nieźle z typowymi przypadkami
        osób, znajduje określenia temporalne i miejscowości.
        </p>
        <img src="/static/img_zapiski/jupyter_spacy.png" width="685" alt="jupyter_spacy"/>

        <p>Niektóre z postaci, np. Barnim XI (książę pomorski, w dalszej niewidocznej na zrzucie
        ekranu części tekstu) pozostają jednak nierozpoznane, jako osoby rozpoznawane są natomiast
        błędnie wyrażenia typu: 'Odstraszała' czy 'Podniosłyby', model użyty do testu był
        przygotowany na podstawie bardziej współczesnych tekstów stąd imion i innych określeń
        używanych historyczne po prostu nie zna. Analizowany tekst dotyczy XVI wieku, ale gdyby
        występowały w nim postacie średniowieczne typu 'Jan z Goźlic' jako osoba zostałoby
        uznane prawdopodobnie tylko imię Jan a nie całe wyrażenie. Zdarzają się też błędne
        rozpoznania miejsc jako osób itp. Czy można model 'przekonać' do poprawnego rozpoznawania
        takich określeń? Oczywiście, istnieją także zapewne lepsze modele, ale jest to temat na
        inny wpis.</p>

        <p>
        Mając tekst z informacjami o numerach stronach, możliwość rozpoznania postaci analizą NER,
        możemy przygotować ich indeks, posłuży do tego skrypt pythonowy create_index.py
        <label for="%s" class="margin-toggle sidenote-number"></label>
        <input type="checkbox" id="%s" class="margin-toggle"/>
        <span class="sidenote">Do pobrania z serwisu <a href="https://github.com/pjaskulski/zapiski">github</a>.
        </span>
        w którym najpierw wczytywana jest treść każdej strony,
        wykonywana analiza NER, wyniki dopisywanie do słownika wyników, na koniec wyświetlana
        jest posortowana lista znalezionych postaci (266 osób, z tym że niektóre występują czasem
        podwójnie lub potrójnie z powodu np. literówek czy błędnie ustalonej formy podstawowej
        imienia i nazwiska) wraz z numerami stron. Lista nie jest z pewnością dokładna, wymaga
        oczyszczenia przez człowieka (występują wspomniane już wyżej błędne rozpoznania, problemy
        z odmianą imion i nazwisk, jakość ocr też wpływa na błędy wynikające z literówek) jednak
        z pewnością jest dużym ułatwieniem przy tworzeniu indeksu, no i jej przygotowaniem zajął
        się komputer, dając człowiekowi czas na zadania, których komputer na dziś nie jest w stanie
        się podjąć. Poniżej fragment przygotowanego indeksu po wstępnym oczyszczeniu.
        </p>

        <p>
        <code>
        Achacy Czema [262]<br>
        Adam Konarski [190, 273]<br>
        Adolf (holsztyński) [157]<br>
        Albrecht Giese [88, 120, 171]<br>
        Albrecht Wilkowski [116]<br>
        Albrecht (Hohenzollern) [43, 44, 51, 52, 56, 57, 58, 70, 134]<br>
        Aleksander Połubieński [216]<br>
        Andrzej Swarożyński [74, 81, 84, 104, 274]<br>
        Antoni Angela [44]<br>
        Bajerski [93, 94]<br>
        Barnim XI [126, 187]<br>
        Bąkowski [138]<br>
        Birsen [46]<br>
        Bogusław XIII [187]<br>
        Boleman [177, 178]<br>
        Chodkiewicz [101, 191, 207, 228, 263, 270, 271]<br>
        [...]<br>
        Łukasz Górnicki [43]<br>
        Łukasz Podoski [190, 222, 273]<br>
        Maciej Scharping [58, 60, 67, 74, 83]<br>
        Maciej Strubicz [77, 271]<br>
        </code>
        </p>

        </section>
    </article>
{{end}}
